#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <syslog.h>
#include <signal.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <utility>
#include <iostream>
#include <unordered_map>
#include <iomanip>

using namespace std;

struct dateHash
{
    unsigned long long id, size, modified, min_folder_size;
    int id_job;
    int fisiere_verif, foldere_verif, nr_foldere, nr_fisiere;
    int stare; // -1- terminat, 0 - nu exista, 1  -in progres, 2- pauza
    int nr_units;
    const char* start_folder;
    pthread_t thrd_count, thrd_size;
    int stop; //1 pt terminare, 2 pt pauza
    
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
};

unordered_map <string, dateHash> cache;

const char* paths[1000];

unsigned long long folder_id;
unsigned long long job_id;

void verif_terminare_pauza(const char* folderPath)
{
    pthread_mutex_t &mutex = cache[cache[folderPath].start_folder].mutex;
    pthread_cond_t &cond = cache[cache[folderPath].start_folder].cond;
    if(cache[cache[folderPath].start_folder].stop > 0) //oprire
    {
        if(cache[cache[folderPath].start_folder].stop == 1) //terminare
        {
            cache[cache[folderPath].start_folder].stare = -1;
            pthread_exit(NULL);
        }
        else //pauza
        {
            pthread_mutex_lock(&mutex);
            
            while (cache[cache[folderPath].start_folder].stop==2)
            {
                pthread_cond_wait(&cond, &mutex);
                sleep(5);
            }
            
            pthread_mutex_unlock(&mutex);
        }
    }
}

void initialize_cache(const char* folderPath,  struct stat statBuf)
{
    cout << folderPath << '\n';
    
    folder_id++;
    cache[folderPath].id = folder_id;
    paths[folder_id] = folderPath;
    cache[folderPath].modified =statBuf.st_mtime;
    cache[folderPath].stare =  1;
    cache[folderPath].min_folder_size = ULLONG_MAX;
}

void calculateFolderSize(void* folderPath0)
{
    const char* folderPath = (const char*)folderPath0;
    DIR *dir;
    struct dirent *entry;
    struct stat statBuf;
    int fisiere_verif = 0, foldere_verif=0;
    long long size = 0;
    unsigned long long min_folder_size = ULLONG_MAX;
    
    verif_terminare_pauza(folderPath);

    if ((dir = opendir(folderPath)) == NULL)
    {
        perror("opendir");
        exit(EXIT_FAILURE);
    }

    if (stat(folderPath, &statBuf) == -1)
        perror("stat");

    if (cache[folderPath].modified != statBuf.st_mtime)
    {
        initialize_cache(folderPath, statBuf);

        while ((entry = readdir(dir)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;

            char filePath[PATH_MAX];
            snprintf(filePath, sizeof(filePath), "%s/%s", folderPath, entry->d_name);

            // Get information about the file
            if (stat(filePath, &statBuf) == -1)
            {
                perror("stat");
                continue;  // Skip to the next entry if stat fails
            }

            if (S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode))
            {
                size += statBuf.st_size;
                fisiere_verif++;
                
                cache[cache[folderPath].start_folder].fisiere_verif++;
            }
            else if (S_ISDIR(statBuf.st_mode))
            {
                char dirPath[PATH_MAX];
                snprintf(dirPath, sizeof(dirPath), "%s/%s", folderPath, entry->d_name);
                
                cache[dirPath].start_folder = cache[folderPath].start_folder;
                
                
                
                calculateFolderSize(dirPath);
                foldere_verif++;
                cache[cache[folderPath].start_folder].foldere_verif++;
                
                
                size += cache[dirPath].size;
                fisiere_verif += cache[dirPath].fisiere_verif;
                foldere_verif += cache[dirPath].foldere_verif;
                if(cache[dirPath].size > 0)
                    min_folder_size = min(min_folder_size, cache[dirPath].size);
            }
        }
        cache[folderPath].size = size;
        cache[folderPath].fisiere_verif = fisiere_verif;
        cache[folderPath].foldere_verif = foldere_verif;
        cache[folderPath].min_folder_size = min(min_folder_size,  cache[folderPath].size);
    }
    else
    {
        std::cout << " precalculat - " << folderPath  << "\n";
    }

    closedir(dir);
}


void countItemsFolder(void *folderPath0)
{
    const char* folderPath = (const char*) folderPath0;
    DIR *dir;
    int nr_foldere=0, nr_fisiere=0, fisiere_verif = 0, foldere_verif = 0;
    struct stat statBuf;
    struct dirent *entry;
    
    verif_terminare_pauza(folderPath);

    if ((dir = opendir(folderPath)) == NULL)
    {
        perror("opendir");
        exit(EXIT_FAILURE);
    }
    
    if (stat(folderPath, &statBuf) == -1)
        perror("stat");

    if (cache[folderPath].modified != statBuf.st_mtime)
    {
        //aici nu punem ca fi modificat, doar in CalculateSize
        
        while ((entry = readdir(dir)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            
            char filePath[PATH_MAX];
            snprintf(filePath, sizeof(filePath), "%s/%s", folderPath, entry->d_name);
            if(stat(filePath, &statBuf) == -1)
                perror("stat");
            
            if (S_ISREG(statBuf.st_mode) || S_ISLNK(statBuf.st_mode))
            {
                //cout << entry->d_name << ", ";
                nr_fisiere++;
            }
            else
            {
                char dirPath[PATH_MAX];
                nr_foldere++;
                
                //cout << "\n" << entry->d_name << " : ";
                snprintf(dirPath, sizeof(dirPath), "%s/%s", folderPath, entry->d_name);
                
                cache[dirPath].start_folder = cache[folderPath].start_folder;
                //!aici atentie
                countItemsFolder(dirPath);
                
                nr_foldere += cache[dirPath].nr_foldere;
                nr_fisiere += cache[dirPath].nr_fisiere;
                fisiere_verif += cache[dirPath].fisiere_verif;
                foldere_verif += cache[dirPath].foldere_verif;
            }
        }
    }
    else
    {
        std::cout << " precalculat" << folderPath  << "\n";
        nr_fisiere = cache[folderPath].nr_fisiere;
        nr_foldere = cache[folderPath].nr_foldere;
        fisiere_verif = cache[folderPath].fisiere_verif;
        foldere_verif = cache[folderPath].foldere_verif;
        
    }
    cache[folderPath].nr_foldere = nr_foldere;
    cache[folderPath].nr_fisiere = nr_fisiere;
    cache[folderPath].fisiere_verif = fisiere_verif;
    cache[folderPath].foldere_verif = foldere_verif;

    // Close the directory
    closedir(dir);
}

int isInTask(const char *folderPath)
{
        const char *lastSeparator = strrchr(folderPath, '/');
        
        if (lastSeparator != nullptr)
        {
            // Calculate the length of the parent folder path
            size_t parentPathLength = lastSeparator - folderPath;
            
            char parentFolderPath[PATH_MAX];
            
            // Copy the parent folder path
            strncpy(parentFolderPath, folderPath, parentPathLength);
            
            // Null-terminate the string
            parentFolderPath[parentPathLength] = '\0';
            
            auto it = cache.find(parentFolderPath);
            if(it != cache.end())
                return cache[parentFolderPath].id;
            
            return isInTask(parentFolderPath);
            
        }
        else {
            return 0;
        }
}

void Progress(const char *folderPath, int id)
{
    auto it = cache.find(folderPath);
    if(it != cache.end())
    {
        if(cache[folderPath].stare == -1)
        {
            cout << "Taskul este terminat \n";
            cout << "dimensiune : " << cache[folderPath].size << "\n verif: " << cache[folderPath].fisiere_verif << " total fisiere : " << cache[folderPath].nr_fisiere  << " total foldere : " << cache[folderPath].nr_foldere << '\n';
            return;
        }
        if(cache[folderPath].stare == 2)
        {
            cout << "Taskul este in pauza \n";
            return;
        }
        if(cache[folderPath].stare == 1)
        {
            cout << "In progres: " << ((double) cache[folderPath].fisiere_verif)/ cache[folderPath].nr_fisiere * 100 << "% ";
            cout << " dimensiune : " << cache[folderPath].size << "\n fisiere verif: " << cache[folderPath].fisiere_verif <<  "\n foldere verif: " << cache[folderPath].foldere_verif << " total fisiere : " << cache[folderPath].nr_fisiere  << " total foldere : " << cache[folderPath].nr_foldere << '\n';
            return;
        }
    }
    else
    {
        cout << "\n Taskul " << id << " nu exista \n";
        return;
    }
    //printf (" deja verif: %d , total: %d \n", cache[folderPath].fisiere_verif, cache[folderPath].nr_fisiere);
    
}

void resultAnalysis(const char* folderPath)
{
    DIR *dir;
    struct dirent *entry;
    struct stat statBuf;

    if ((dir = opendir(folderPath)) == NULL)
    {
        perror("opendir");
        exit(EXIT_FAILURE);
    }

    if (stat(folderPath, &statBuf) == -1)
        perror("stat");

    char aux[PATH_MAX];
    
    strcpy(aux, folderPath + strlen(cache[folderPath].start_folder)+1);
    
    if(aux[0] != '\0')
    {
        if(folderPath != cache[folderPath].start_folder)
        {
            cout << "|-/" << aux << " ";
            double proc = ((double) cache[folderPath].size) /  cache[cache[folderPath].start_folder].size;
            cout << setprecision(2) << proc * 100  << "% ";
            double nr_mb = ((double) cache[folderPath].size) / 1000000;
            cout << setprecision(2) << nr_mb << " MB ";
            
            int nr_units = (int) (cache[folderPath].size / cache[cache[folderPath].start_folder].min_folder_size);
            for (int i = 1; i<= nr_units; i++)
                cout << "#";
            cout << '\n';
        }
        else{ //este radacina
            cout << "\n Path                 Usage       Size         Amount \n";
            cout << folderPath << " 100% ";
            double nr_mb = ((double) cache[folderPath].size) / 1000000;
            cout << setprecision(2) << nr_mb << " MB ";
            
            int nr_units = (int) (cache[folderPath].size / cache[folderPath].min_folder_size);
            cache[folderPath].nr_units = nr_units;
            
            for (int i = 1; i<= nr_units; i++)
                cout<< "#";
            cout << "\n| \n";
        }
        
        while ((entry = readdir(dir)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            
            char filePath[PATH_MAX];
            snprintf(filePath, sizeof(filePath), "%s/%s", folderPath, entry->d_name);
            
            // Get information about the file
            if (stat(filePath, &statBuf) == -1)
            {
                perror("stat");
                continue;  // Skip to the next entry if stat fails
            }
            
            if (S_ISDIR(statBuf.st_mode))
            {
                char dirPath[PATH_MAX];
                snprintf(dirPath, sizeof(dirPath), "%s/%s", folderPath, entry->d_name);
                
                resultAnalysis(dirPath);
            }
        }
    }
    closedir(dir);
}

void StartTask(const char *folderPath)
{
    int rez = isInTask(folderPath);
    if(rez != 0)
    {
        cout << "\n Este deja in taskul " << rez <<'\n';
        return;
    }
    
    cache[folderPath].start_folder = folderPath;
    cache[folderPath].id_job= ++job_id;
    
    //aici pe threaduri separate
    if (pthread_create(&cache[folderPath].thrd_count, NULL, countItemsFolder, (void*)folderPath) != 0)
    {
        perror(NULL);
        return;
    }
    
    if (pthread_create(&cache[folderPath].thrd_size, NULL, calculateFolderSize, (void*)folderPath) != 0)
        {
            perror(NULL);
            return;
        }
        
    if (pthread_join(cache[folderPath].thrd_count, NULL)) {
        perror(NULL);
        return;
    }
    if (pthread_join(cache[folderPath].thrd_size, NULL)) {
        perror(NULL);
        return;
    }

    cache[folderPath].stare = -1; //terminat
    
    resultAnalysis(folderPath);
}

void listAllTasks(){
    for (int i = 1; i<= job_id; i++)
    {
        const char *folderPath = paths[i];
        cout << i << " *** " << folderPath << " " << ((double) cache[folderPath].fisiere_verif)/ cache[folderPath].nr_fisiere * 100 << " " << cache[folderPath].fisiere_verif << " fisiere deja verificate" << cache[folderPath].foldere_verif << " foldere deja verificate\n";
    }
}

void stop_pause_resume(int id, int what) //what: 1 - stop , 2- pause, 0 - resume
{
    const char *folderPath = paths[id];
    cache[folderPath].stop = what;
}

int main()
{
    const char *s1 = "/Users/anastasiastefanescu/Documents/uf";
    const char *s2= "/Users/anastasiastefanescu/Documents/SO";
   
    //printf("%lld foldere, %lld fisiere \n", getFolderItemCount(s).first, getFolderItemCount(s).second);
    //printf("\n %lf GB \n", calculateFolderSize(s)/1000000);
    
    //StartTask(s2);
    
    //Progress(s2);
    
   // StartTask(s2);
    
    //Progress(s2);
    
    StartTask(s2);
    
    return 0;
}

//atentie - obligatoriu cand CalculateSize ii dam CountItems, dar pe un thread separat(ca sa nu pierdem timpul) - pt ca vrem sa stim cat mai repede nr de fisiere, nr_foldere si cate fisiere au mai fost verificate in taskuri anterioare.

//In CalculateSize, nu adaugam la nr_verificate daca am gasit un folder deja calculat - adaugam numai fisierele neparcurse pana acum
